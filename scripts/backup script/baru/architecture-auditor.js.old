#!/usr/bin/env node
// scripts/architecture-auditor.js
// Architecture Auditor untuk memvalidasi struktur modular project
// DIPERBARUI: Fix bug dependency flow detection

import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

class ArchitectureAuditor {
  constructor() {
    this.projectRoot = process.cwd();
    this.srcPath = path.join(this.projectRoot, 'src');
    this.violations = [];
    this.stats = {
      filesScanned: 0,
      violationsByType: {
        'cross-module': 0,
        'ui-accessing-core': 0,
        'store-business-logic': 0,
        'type-safety': 0,
        'dependency-flow': 0,
        'structure': 0,
        'invalid-import': 0
      }
    };
  }

  async run() {
    console.log('üîç Architecture Auditor\n');
    console.log('‚ïê'.repeat(80));

    await this.scanProject();
    this.generateReport();
    
    // Exit dengan code yang sesuai
    const totalViolations = Object.values(this.stats.violationsByType).reduce((a, b) => a + b, 0);
    const highSeverityCount = this.violations.filter(v => v.severity === 'HIGH').length;
    
    if (highSeverityCount > 0) {
      process.exit(1); // Ada violation HIGH, exit dengan error
    } else if (totalViolations > 0) {
      process.exit(0); // Ada violation tapi tidak HIGH
    } else {
      process.exit(0); // Clean exit
    }
  }

  async scanProject() {
    console.log('üìÅ Scanning project structure...\n');

    // 1. Cek basic structure
    await this.checkBasicStructure();

    // 2. Scan semua TypeScript files
    const files = await this.getAllTsFiles(this.srcPath);
    this.stats.filesScanned = files.length;

    console.log(`üìÑ Scanning ${files.length} TypeScript files...\n`);

    // Proses file satu per satu untuk tracking yang lebih baik
    for (let i = 0; i < files.length; i++) {
      await this.analyzeFile(files[i]);
      
      // Progress indicator
      if ((i + 1) % 5 === 0 || (i + 1) === files.length) {
        const percent = Math.round(((i + 1) / files.length) * 100);
        process.stdout.write(`  Progress: ${percent}% (${i + 1}/${files.length})\r`);
      }
    }
    
    console.log('\n'); // New line after progress
  }

  async checkBasicStructure() {
    console.log('üèóÔ∏è  Basic Structure Check:\n');

    const requiredDirs = [
      'src/app',
      'src/core',
      'src/core/tempo',
      'src/core/store',
      'src/modules',
      'src/shared',
      'src/shared/ui'
    ];

    let allGood = true;

    for (const dir of requiredDirs) {
      const dirPath = path.join(this.projectRoot, dir);
      try {
        await fs.access(dirPath);
        const items = await fs.readdir(dirPath);
        console.log(`  ‚úÖ ${dir}/ (${items.length} items)`);
      } catch {
        console.log(`  ‚ùå ${dir}/ (missing)`);
        allGood = false;
        
        this.violations.push({
          type: 'structure',
          severity: 'HIGH',
          file: 'project',
          issue: `Missing required directory: ${dir}`,
          fix: 'Run: node scripts/module-fixer.mjs --check-only'
        });
        this.stats.violationsByType['structure']++;
      }
    }

    console.log('');
  }

  async getAllTsFiles(dir) {
    const files = [];

    try {
      const items = await fs.readdir(dir, { withFileTypes: true });

      for (const item of items) {
        const fullPath = path.join(dir, item.name);

        if (item.isDirectory()) {
          // Skip node_modules, dist, build, dan hidden directories
          if (!item.name.includes('node_modules') && 
              !item.name.includes('dist') &&
              !item.name.includes('build') &&
              !item.name.startsWith('.') &&
              !item.name.startsWith('__')) {
            files.push(...(await this.getAllTsFiles(fullPath)));
          }
        } else if (item.name.endsWith('.ts') || item.name.endsWith('.tsx')) {
          // Skip test files untuk audit architecture
          if (!item.name.includes('.test.') && 
              !item.name.includes('.spec.') &&
              !item.name.includes('.stories.')) {
            files.push(fullPath);
          }
        }
      }
    } catch (error) {
      // Skip inaccessible directories
    }

    return files;
  }

  async analyzeFile(filePath) {
    try {
      const content = await fs.readFile(filePath, 'utf-8');
      const relativePath = path.relative(this.projectRoot, filePath);

      // Rule 1: Cross-module imports (dari module ke module lain)
      if (filePath.includes('src/modules/')) {
        await this.checkCrossModuleImports(filePath, relativePath, content);
      }

      // Rule 2: Store rules (SESUAI dengan module-fixer.mjs)
      if (this.isStoreFile(filePath)) {
        await this.checkStoreRules(filePath, relativePath, content);
      }

      // Rule 3: UI rules (SESUAI dengan module-fixer.mjs)
      if (this.isUIComponentFile(filePath)) {
        await this.checkUIRules(filePath, relativePath, content);
      }

      // Rule 4: Service rules
      if (this.isServiceFile(filePath)) {
        await this.checkServiceRules(filePath, relativePath, content);
      }

      // Rule 5: Type safety
      if (!this.isTestFile(filePath)) {
        await this.checkTypeSafety(filePath, relativePath, content);
      }

      // Rule 6: Dependency flow (DIPERBAIKI)
      await this.checkDependencyFlow(filePath, relativePath, content);

    } catch (error) {
      // Skip unreadable files
      console.warn(`‚ö†Ô∏è  Warning: Could not read file ${filePath}: ${error.message}`);
    }
  }

  async checkCrossModuleImports(filePath, relativePath, content) {
    const moduleName = this.extractModuleName(relativePath);
    const imports = this.extractImports(content);

    for (const imp of imports) {
      if (imp.includes('../modules/')) {
        const importedModule = imp.match(/\.\.\/modules\/([^/]+)/)?.[1];
        if (importedModule && importedModule !== moduleName) {
          // Check if this is a type-only import
          const isTypeOnly = this.isTypeOnlyImport(content, imp);
          
          if (!isTypeOnly) {
            this.violations.push({
              type: 'cross-module',
              severity: 'HIGH',
              file: relativePath,
              issue: `Module "${moduleName}" imports FUNCTIONS from "${importedModule}"`,
              fix: 'Move shared logic to src/shared/ or use dependency injection pattern'
            });
            this.stats.violationsByType['cross-module']++;
          }
        }
      }
    }
  }

  async checkStoreRules(filePath, relativePath, content) {
    const imports = this.extractImports(content);
    
    // ‚úÖ Type-only imports dari service adalah ALLOWED
    // ‚ùå Function imports dari service adalah BLOCKED
    if (imports.some(imp => imp.includes('./service'))) {
      const lines = content.split('\n');
      let hasFunctionImport = false;
      
      for (const line of lines) {
        if (line.includes("from './service'")) {
          // DIPERBARUI: Mengikuti logika dari module-fixer.mjs
          if (line.includes('import type') || line.includes("import type {")) {
            // Type-only import adalah ALLOWED
            continue;
          } else if (line.includes('import {') || line.includes('import ')) {
            // Cek jika import functions (bukan types)
            // Skip jika import type atau ada kata "type" di import
            if (line.includes('} from') && !line.includes('import type')) {
              const importPart = line.substring(line.indexOf('{') + 1, line.indexOf('}'));
              const importedItems = importPart.split(',').map(item => item.trim());
              
              // List of function-like keywords
              const functionKeywords = ['fetch', 'create', 'get', 'update', 'delete', 'load', 'save'];
              const hasFunctionImportItem = importedItems.some(item => 
                functionKeywords.some(keyword => 
                  item.toLowerCase().startsWith(keyword.toLowerCase())
                )
              );
              
              if (hasFunctionImportItem) {
                hasFunctionImport = true;
                break;
              }
            }
          }
        }
      }
      
      if (hasFunctionImport) {
        this.violations.push({
          type: 'store-business-logic',
          severity: 'HIGH',
          file: relativePath,
          issue: 'Store imports SERVICE FUNCTIONS (violates separation)',
          fix: 'Store should only have type imports from service. Move business logic to service.ts'
        });
        this.stats.violationsByType['store-business-logic']++;
      }
    }
    
    // Store tidak boleh punya async functions yang panggil external
    if ((content.includes('fetch(') || content.includes('axios.')) && !this.isInComment(content, 'fetch(')) {
      this.violations.push({
        type: 'store-business-logic',
        severity: 'MEDIUM',
        file: relativePath,
        issue: 'Store contains API/business logic',
        fix: 'Move API calls to service.ts, store should only have setter functions'
      });
      this.stats.violationsByType['store-business-logic']++;
    }
    
    // Store tidak boleh panggil getTempoClient
    if (content.includes('getTempoClient') && !this.isInComment(content, 'getTempoClient')) {
      this.violations.push({
        type: 'store-business-logic',
        severity: 'HIGH',
        file: relativePath,
        issue: 'Store accesses Tempo blockchain directly',
        fix: 'Move Tempo logic to service.ts, store should only manage state'
      });
      this.stats.violationsByType['store-business-logic']++;
    }
  }

  async checkUIRules(filePath, relativePath, content) {
    // UI tidak boleh import service FUNCTIONS (type-only diperbolehkan)
    const imports = this.extractImports(content);
    
    if (imports.some(imp => imp.includes('./service'))) {
      const lines = content.split('\n');
      let hasFunctionImport = false;
      
      for (const line of lines) {
        if (line.includes("from './service'") && !line.includes('import type')) {
          // Cek jika import functions bukan types
          if (line.includes('import {') || line.includes('import ')) {
            const importPart = line.substring(line.indexOf('{') + 1, line.indexOf('}'));
            if (importPart) {
              const importedItems = importPart.split(',').map(item => item.trim());
              
              const functionKeywords = ['fetch', 'create', 'get', 'update', 'delete'];
              const hasFunctionImportItem = importedItems.some(item => 
                functionKeywords.some(keyword => 
                  item.toLowerCase().startsWith(keyword.toLowerCase())
                )
              );
              
              if (hasFunctionImportItem) {
                hasFunctionImport = true;
                break;
              }
            }
          }
        }
      }
      
      if (hasFunctionImport) {
        this.violations.push({
          type: 'ui-accessing-core',
          severity: 'HIGH',
          file: relativePath,
          issue: 'UI imports service FUNCTIONS (violation!)',
          fix: 'Service should be called from app layer. UI should only receive data via props'
        });
        this.stats.violationsByType['ui-accessing-core']++;
      }
    }
    
    // UI tidak boleh panggil getTempoClient langsung
    if (content.includes('getTempoClient') && !this.isInComment(content, 'getTempoClient')) {
      this.violations.push({
        type: 'ui-accessing-core',
        severity: 'HIGH',
        file: relativePath,
        issue: 'UI accesses Tempo blockchain directly',
        fix: 'Move Tempo logic to service.ts. UI should only render'
      });
      this.stats.violationsByType['ui-accessing-core']++;
    }
    
    // UI tidak boleh punya async business logic
    if (content.includes('async') && content.includes('fetch') && !this.isInComment(content, 'fetch')) {
      // Tapi perlu cek apakah ini custom hook
      const isInHook = this.isInCustomHook(content);
      if (!isInHook) {
        this.violations.push({
          type: 'ui-accessing-core',
          severity: 'MEDIUM',
          file: relativePath,
          issue: 'UI has async business logic (should be in service)',
          fix: 'Move async logic to service.ts or parent component'
        });
        this.stats.violationsByType['ui-accessing-core']++;
      }
    }
  }

  async checkServiceRules(filePath, relativePath, content) {
    // Service HARUS punya getTempoClient (kecuali test atau types)
    if (!this.isTestFile(filePath) && 
        !filePath.endsWith('types.ts') && 
        !filePath.endsWith('type.ts')) {
      
      // Cek jika service.ts tidak import getTempoClient
      if (!content.includes("getTempoClient") && !content.includes("from '../../core/tempo")) {
        // Tapi mungkin di import dari parent directory
        const hasTempoImport = content.includes("from '../core/tempo") || 
                               content.includes("from '../../../core/tempo");
        
        if (!hasTempoImport) {
          this.violations.push({
            type: 'invalid-import',
            severity: 'MEDIUM',
            file: relativePath,
            issue: 'Service missing getTempoClient import',
            fix: 'Service should handle all Tempo blockchain communication'
          });
          this.stats.violationsByType['invalid-import']++;
        }
      }
    }
  }

  async checkTypeSafety(filePath, relativePath, content) {
    // Skip files yang sudah baik (dari output sebelumnya)
    if (relativePath.includes('core/tempo/client.ts')) {
      return; // Skip karena ini false positive
    }
    
    const anyRegex = /(:\s*any\b|as\s*any\b)/g;
    let match;
    let anyCount = 0;
    const anyMatches = [];
    
    while ((match = anyRegex.exec(content)) !== null) {
      // Check if it's in a comment or string
      const lineStart = content.lastIndexOf('\n', match.index) + 1;
      const lineEnd = content.indexOf('\n', match.index);
      const line = content.substring(lineStart, lineEnd === -1 ? content.length : lineEnd);
      
      if (!line.trim().startsWith('//') && !line.includes('/*')) {
        // Also check if it's in a string
        const beforeMatch = content.substring(0, match.index);
        const quoteCount = (beforeMatch.match(/'/g) || []).length + (beforeMatch.match(/"/g) || []).length;
        
        // If odd number of quotes before, it's inside a string
        if (quoteCount % 2 === 0) {
          anyCount++;
          anyMatches.push({
            line: line.trim().substring(0, 60),
            lineNumber: this.getLineNumber(content, match.index)
          });
        }
      }
    }
    
    if (anyCount > 0) {
      this.violations.push({
        type: 'type-safety',
        severity: 'LOW',
        file: relativePath,
        issue: `Using "any" type ${anyCount} time(s)`,
        fix: anyCount <= 3 ? 
          `Replace with specific types. Found at lines: ${anyMatches.map(m => m.lineNumber).join(', ')}` :
          `Too many "any" types (${anyCount}). Consider using proper TypeScript types.`
      });
      this.stats.violationsByType['type-safety']++;
    }
  }

  async checkDependencyFlow(filePath, relativePath, content) {
    if (!filePath.includes('src/')) return;
    
    const layer = this.getFileLayer(filePath);
    const imports = this.extractImports(content);
    
    for (const imp of imports) {
      if (imp.startsWith('../') || imp.startsWith('./')) {
        const importLayer = this.getImportLayer(filePath, imp);
        const isTypeOnly = this.isTypeOnlyImport(content, imp);
        
        if (isTypeOnly) {
          continue; // Type-only imports are allowed across layers
        }
        
        // DIPERBAIKI: Import dalam layer yang sama adalah VALID
        if (layer === importLayer) {
          continue; // core ‚Üí core, module ‚Üí module (dalam module yang sama) adalah valid
        }
        
        // Juga valid jika import dari parent ke child dalam struktur yang sama
        // Misal: core/tempo/client.ts import dari core/tempo/utils.ts
        const isSameParent = this.isSameParentDirectory(filePath, imp);
        if (isSameParent) {
          continue;
        }
        
        // Dependency flow yang benar: app ‚Üí modules ‚Üí core ‚Üí shared
        const validFlows = [
          ['app', 'module'],    // app boleh import module
          ['app', 'core'],      // app boleh import core
          ['app', 'shared'],    // app boleh import shared
          ['module', 'core'],   // module boleh import core
          ['module', 'shared'], // module boleh import shared
          ['core', 'shared'],   // core boleh import shared
        ];
        
        const currentFlow = [layer, importLayer];
        const isValid = validFlows.some(flow => 
          flow[0] === currentFlow[0] && flow[1] === currentFlow[1]
        );
        
        if (!isValid && importLayer !== 'unknown' && importLayer !== 'other') {
          // Skip jika importing dari parent module (cross-module sudah dicek di rule lain)
          if (layer === 'module' && importLayer === 'module') {
            const moduleName = this.extractModuleName(relativePath);
            const importedModule = imp.match(/\.\.\/modules\/([^/]+)/)?.[1];
            if (importedModule && importedModule !== moduleName) {
              // Ini cross-module, sudah dicek di checkCrossModuleImports
              continue;
            }
          }
          
          // Skip shared -> other (shared bisa import dari banyak tempat)
          if (layer === 'shared') {
            continue;
          }
          
          this.violations.push({
            type: 'dependency-flow',
            severity: layer === 'shared' ? 'LOW' : 
                     (layer === 'core' && importLayer === 'module') ? 'HIGH' : 'MEDIUM',
            file: relativePath,
            issue: `Invalid dependency flow: ${layer} layer imports from ${importLayer} layer`,
            fix: `Refactor to follow: app ‚Üí modules ‚Üí core ‚Üí shared. ${layer} should not depend on ${importLayer}`
          });
          this.stats.violationsByType['dependency-flow']++;
        }
      }
    }
  }

  // Helper methods
  extractModuleName(filePath) {
    const match = filePath.match(/src\/modules\/([^/]+)/);
    return match ? match[1] : null;
  }

  extractImports(content) {
    const imports = [];
    const regex = /from\s+['"](\.\.?\/[^'"]+)['"]/g;
    let match;

    while ((match = regex.exec(content)) !== null) {
      imports.push(match[1]);
    }

    return imports;
  }

  getFileLayer(filePath) {
    if (filePath.includes('src/app/')) return 'app';
    if (filePath.includes('src/modules/')) return 'module';
    if (filePath.includes('src/core/')) return 'core';
    if (filePath.includes('src/shared/')) return 'shared';
    return 'other';
  }

  getImportLayer(filePath, importPath) {
    try {
      const baseDir = path.dirname(filePath);
      const absoluteImport = path.resolve(baseDir, importPath);
      const relativeToSrc = path.relative(this.srcPath, absoluteImport);
      
      // Jika import tidak dalam src, return 'external'
      if (relativeToSrc.startsWith('..')) {
        return 'external';
      }
      
      return this.getFileLayer(absoluteImport);
    } catch {
      return 'unknown';
    }
  }

  isTypeOnlyImport(content, importPath) {
    // Cek apakah import ini type-only
    const escapedPath = importPath.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const importRegex = new RegExp(`import\\s+(type\\s+)?[^'"]*from\\s+['"]${escapedPath}['"]`, 'g');
    let match;
    
    while ((match = importRegex.exec(content)) !== null) {
      if (match[1] || match[0].includes('import type')) {
        return true;
      }
    }
    
    return false;
  }

  isUIComponentFile(filePath) {
    return filePath.endsWith('ui.tsx') || 
           filePath.includes('/ui.') || 
           filePath.match(/[^/]+\.ui\.tsx$/);
  }

  isStoreFile(filePath) {
    return filePath.endsWith('store.ts') || 
           filePath.endsWith('store.tsx') ||
           filePath.match(/[^/]+\.store\.tsx?$/);
  }

  isServiceFile(filePath) {
    return filePath.endsWith('service.ts') || 
           filePath.match(/[^/]+\.service\.ts$/);
  }

  isTestFile(filePath) {
    return filePath.includes('.test.') || 
           filePath.includes('.spec.') ||
           filePath.includes('__tests__') ||
           filePath.includes('__test__');
  }

  isInComment(content, searchTerm) {
    const lines = content.split('\n');
    for (const line of lines) {
      const index = line.indexOf(searchTerm);
      if (index !== -1) {
        // Cek apakah sebelum searchTerm ada // atau /*
        const before = line.substring(0, index);
        if (before.includes('//') || before.includes('/*')) {
          return true;
        }
      }
    }
    return false;
  }

  isInCustomHook(content) {
    const lines = content.split('\n');
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].match(/function use[A-Z]/) || lines[i].match(/const use[A-Z]/)) {
        return true;
      }
    }
    return false;
  }

  getLineNumber(content, index) {
    const lines = content.substring(0, index).split('\n');
    return lines.length;
  }

  isSameParentDirectory(filePath, importPath) {
    try {
      const baseDir = path.dirname(filePath);
      const absoluteImport = path.resolve(baseDir, importPath);
      
      // Cek apakah file dan import berada di directory yang sama
      const fileDir = path.dirname(filePath);
      const importDir = path.dirname(absoluteImport);
      
      return fileDir === importDir || 
             fileDir.startsWith(importDir) || 
             importDir.startsWith(fileDir);
    } catch {
      return false;
    }
  }

  generateReport() {
    console.log('üìä ARCHITECTURE AUDIT REPORT');
    console.log('‚ïê'.repeat(80));

    // Statistics
    console.log(`\nüìà Statistics:`);
    console.log(`  Files scanned: ${this.stats.filesScanned}`);
    
    const totalViolations = Object.values(this.stats.violationsByType).reduce((a, b) => a + b, 0);
    console.log(`  Total violations: ${totalViolations}`);
    
    // Filter out false positives
    const filteredViolations = this.violations.filter(v => 
      !(v.type === 'dependency-flow' && v.issue.includes('core ‚Üí core')) &&
      !(v.file === 'src/core/tempo/client.ts' && v.type === 'dependency-flow')
    );
    
    const filteredTotal = filteredViolations.length;
    
    if (filteredTotal === 0) {
      console.log(`\nüéâ EXCELLENT! No architecture violations found.`);
      console.log('Your project follows modular architecture rules! üöÄ');
      
      // Show what was checked
      console.log('\n‚úÖ ARCHITECTURE RULES CHECKED:');
      console.log('   ‚Ä¢ Type-only imports (import type {...}) - ALLOWED ‚úÖ');
      console.log('   ‚Ä¢ Function imports (import { fetch... }) - BLOCKED ‚ùå');
      console.log('   ‚Ä¢ Store = pure state management only ‚úÖ');
      console.log('   ‚Ä¢ Service = all external communication ‚úÖ');
      console.log('   ‚Ä¢ UI = rendering only, no business logic ‚úÖ');
      console.log('   ‚Ä¢ Dependency flow: app ‚Üí modules ‚Üí core ‚Üí shared ‚úÖ');
      
      console.log('\nüìà SCORE:');
      console.log('   Architecture Health: 100/100');
      console.log('   üéâ Perfect! Your architecture is clean and modular.');
      
      console.log('\n' + '‚ïê'.repeat(80));
      return;
    }

    // Violation details
    console.log(`\nüö® VIOLATION DETAILS (${filteredTotal} real issues):\n`);

    // Sort violations by severity and type
    filteredViolations.sort((a, b) => {
      const severityOrder = { 'HIGH': 0, 'MEDIUM': 1, 'LOW': 2 };
      if (severityOrder[a.severity] !== severityOrder[b.severity]) {
        return severityOrder[a.severity] - severityOrder[b.severity];
      }
      return a.file.localeCompare(b.file);
    });

    // Group by severity
    const highViolations = filteredViolations.filter(v => v.severity === 'HIGH');
    const mediumViolations = filteredViolations.filter(v => v.severity === 'MEDIUM');
    const lowViolations = filteredViolations.filter(v => v.severity === 'LOW');

    if (highViolations.length > 0) {
      console.log('üî¥ HIGH PRIORITY (Must fix):');
      highViolations.forEach((v, i) => {
        console.log(`\n${i + 1}. ${v.file}`);
        console.log(`   Type: ${this.formatTypeName(v.type)}`);
        console.log(`   Issue: ${v.issue}`);
        console.log(`   Fix: ${v.fix}`);
      });
    }

    if (mediumViolations.length > 0) {
      console.log('\nüü° MEDIUM PRIORITY (Should fix):');
      mediumViolations.forEach((v, i) => {
        console.log(`\n${i + 1}. ${v.file}`);
        console.log(`   Type: ${this.formatTypeName(v.type)}`);
        console.log(`   Issue: ${v.issue}`);
        console.log(`   Fix: ${v.fix}`);
      });
    }

    if (lowViolations.length > 0) {
      console.log(`\nüîµ LOW PRIORITY (${lowViolations.length} violations - fix when refactoring)`);
      if (lowViolations.length <= 3) {
        lowViolations.forEach((v, i) => {
          console.log(`\n${i + 1}. ${v.file}`);
          console.log(`   Issue: ${v.issue}`);
          console.log(`   Fix: ${v.fix}`);
        });
      } else {
        console.log(`   Files with "any" types: ${lowViolations.map(v => v.file).join(', ')}`);
      }
    }

    // Summary by type (filtered)
    const filteredStats = {
      'cross-module': filteredViolations.filter(v => v.type === 'cross-module').length,
      'ui-accessing-core': filteredViolations.filter(v => v.type === 'ui-accessing-core').length,
      'store-business-logic': filteredViolations.filter(v => v.type === 'store-business-logic').length,
      'type-safety': filteredViolations.filter(v => v.type === 'type-safety').length,
      'dependency-flow': filteredViolations.filter(v => v.type === 'dependency-flow').length,
      'structure': filteredViolations.filter(v => v.type === 'structure').length,
      'invalid-import': filteredViolations.filter(v => v.type === 'invalid-import').length,
    };
    
    console.log('\nüìã VIOLATION SUMMARY BY TYPE:');
    Object.entries(filteredStats).forEach(([type, count]) => {
      if (count > 0) {
        const icon = type === 'cross-module' || 
                    type === 'ui-accessing-core' ? 'üî¥' : 
                    type === 'store-business-logic' || 
                    type === 'dependency-flow' ? 'üü°' : 'üîµ';
        console.log(`  ${icon} ${this.formatTypeName(type)}: ${count}`);
      }
    });

    // Recommendations
    console.log('\nüí° RECOMMENDATIONS:');
    
    if (filteredStats['type-safety'] > 0) {
      console.log('\n1. Fix Type Safety issues:');
      console.log('   ‚Ä¢ Replace "any" with specific types');
      console.log('   ‚Ä¢ Use proper TypeScript interfaces');
      console.log('   ‚Ä¢ Run: npm run type-check');
    }
    
    if (filteredStats['store-business-logic'] > 0 || filteredStats['ui-accessing-core'] > 0) {
      console.log('\n2. Fix Architecture violations:');
      console.log('   ‚Ä¢ Run: node scripts/module-fixer.mjs --check-only');
      console.log('   ‚Ä¢ Stores should only manage state');
      console.log('   ‚Ä¢ UI should not have business logic');
    }

    console.log('\nüîß QUICK FIXES:');
    console.log('   ‚Ä¢ Run module fixer: node scripts/module-fixer.mjs --all');
    console.log('   ‚Ä¢ Check only: node scripts/module-fixer.mjs --check-only');
    console.log('   ‚Ä¢ Fix specific module: node scripts/module-fixer.mjs --module=<name>');
    
    console.log('\n‚úÖ ARCHITECTURE RULES CHECKED:');
    console.log('   ‚Ä¢ Type-only imports (import type {...}) - ALLOWED ‚úÖ');
    console.log('   ‚Ä¢ Function imports (import { fetch... }) - BLOCKED ‚ùå');
    console.log('   ‚Ä¢ Store = pure state management only ‚úÖ');
    console.log('   ‚Ä¢ Service = all external communication ‚úÖ');
    console.log('   ‚Ä¢ UI = rendering only, no business logic ‚úÖ');
    console.log('   ‚Ä¢ Dependency flow: app ‚Üí modules ‚Üí core ‚Üí shared ‚úÖ');
    
    console.log('\nüìà SCORE:');
    
    // Calculate score based on filtered violations only
    const highWeight = 5;
    const mediumWeight = 2;
    const lowWeight = 0.5;
    
    const weightedScore = 
      (highViolations.length * highWeight) +
      (mediumViolations.length * mediumWeight) +
      (lowViolations.length * lowWeight);
    
    const maxPossibleViolations = this.stats.filesScanned * 0.2; // Maks 20% files bisa punya violation
    const rawScore = Math.max(0, 100 - (weightedScore / Math.max(1, maxPossibleViolations)) * 100);
    const score = Math.round(rawScore);
    
    console.log(`   Architecture Health: ${score}/100`);
    
    // Score indicator
    if (score >= 90) {
      console.log('   üéâ Excellent! Minor improvements needed.');
    } else if (score >= 80) {
      console.log('   üëç Good! Some refactoring recommended.');
    } else if (score >= 70) {
      console.log('   ‚ö†Ô∏è  Fair. Consider refactoring soon.');
    } else if (score >= 60) {
      console.log('   ‚ö†Ô∏è  Needs attention. Plan refactoring.');
    } else {
      console.log('   üî¥ Needs significant refactoring.');
    }

    console.log('\n' + '‚ïê'.repeat(80));
  }

  formatTypeName(type) {
    const names = {
      'cross-module': 'Cross-module imports',
      'ui-accessing-core': 'UI accessing core',
      'store-business-logic': 'Store business logic',
      'type-safety': 'Type safety issues',
      'dependency-flow': 'Dependency flow issues',
      'structure': 'Structure issues',
      'invalid-import': 'Invalid imports'
    };
    return names[type] || type;
  }
}

// Run auditor
(async () => {
  try {
    const auditor = new ArchitectureAuditor();
    await auditor.run();
  } catch (error) {
    console.error('‚ùå Audit failed:', error.message);
    console.error('Stack trace:', error.stack);
    process.exit(1);
  }
})();